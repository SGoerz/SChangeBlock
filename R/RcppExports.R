# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Gini's mean difference
#' 
#' Calculates Gini's mean difference of a given vector \code{x}.
#' 
#' @param x numeric vector.
#' 
#' @return A numeric value.
#' 
#' @examples
#' x <- rnorm(100)
#' GMD(x)
#' 
#' @export
GMD <- function(x) {
    .Call('_SChangeBlock_GMD', PACKAGE = 'SChangeBlock', x)
}

#' Mu
#' 
#' This function returns a vector of the block means for a given random field X.
#' 
#' @param X Numeric vector or matrix.
#' @param l block length. Numeric vector of length 1 or 2, depending on the number of dimensions of X.
#' 
#' @return A numeric vector of length \code{floor(n[1] / l[1]) * floor(n[2] / l[2])}.
#' 
#' @examples 
#' X <- genField(c(50, 100), H = 100, type = 2)
#' M <- Mu(X, c(10, 20))
#' 
#' plot(X)
#' image(matrix(M, ncol = 5))
#' 
#' @export
Mu <- function(X, l) {
    .Call('_SChangeBlock_Mu', PACKAGE = 'SChangeBlock', X, l)
}

#' Dependency Matrix Theta
#' 
#' This function generates a symmetric dependency matrix \eqn{\Theta} of a 
#' specific type of spatial MA(q) model.
#' 
#' @param q model order (integer).
#' @param param MA parameter (numeric value between 0 and 1).
#' @param structure Character string, either "MA" or "AR" indicating the structure of the dependency matrix. Details below.
#' 
#' @return A matrix of size (2q + 1) x (2q + 1).
#' 
#' @details Symmetric spatial MA(q) model (or an approximation to a spatial AR(1) model):
#'          \deqn{Y_{ij} = \sum_{k = -q}^q \sum_{l = -q}^q \theta_{kl} \varepsilon_{kl}.}
#'          \eqn{\{\theta^{|k - q - 1| + |l - q - 1|}\}_{kl} = \Theta}. \cr \cr
#'          For "MA": \deqn{\theta_{kl} = \code{param}^{|k - q - 1| + |l - q - 1|}.}
#'          For "AR": \deqn{\theta_{kl} = \tilde{\theta}_{kl} / \sqrt{\sum_{|k| \leq q} \sum_{|l| \leq q} \tilde{\theta}^2_{kl}} 
#'          \quad \text{ with } \quad \tilde{\theta}_{kl} = \code{param}^{\sqrt{k^2 + l^2}}.}
#'          
#' @examples
#' genTheta(1, 0.2, "MA")
#' 
#' genTheta(40, 0.2, "AR")
#' 
#' @export
genTheta <- function(q, param, structure = "MA") {
    .Call('_SChangeBlock_genTheta', PACKAGE = 'SChangeBlock', q, param, structure)
}

dependency <- function(E, Theta_ = NULL, q_ = NULL, param_ = NULL) {
    .Call('_SChangeBlock_dependency', PACKAGE = 'SChangeBlock', E, Theta_, q_, param_)
}

#' @export
gamma <- function(X, h1, h2) {
    .Call('_SChangeBlock_gamma', PACKAGE = 'SChangeBlock', X, h1, h2)
}

#' Long run variance
#' 
#' Estimates the long run variance of a 2-dimensional matrix \code{X} using kernel
#' density estimation and the Tukey-Hanning kernel function.
#' 
#' @param X numeric matrix,
#' @param b numeric vector containing exactly two values: the bandwidths for the row- reps. column-wise estimation.
#' 
#' @details ??????? Tukey-Hanning kernel ????????
#' 
#' @return A numeric value.
#' 
#' @examples
#' X1 <- genField(c(50, 50), Phi = genPhi(1, 0.4))
#' b <- bandwidth(X1, 1/3, 2/3)
#' lrv(X1, b)
#' 
#' Phi <- matrix(c(0.08, 0.1, 0.08, 0.8, 1, 0.8, 0.08, 0.1, 0.08), ncol = 3)
#' X2 <- genField(c(50, 50), Phi = Phi)
#' b <- bandwidth(X2, 1/3, 2/3)
#' lrv(X2, b)
#' 
#' @export
lrv <- function(X, b = 1L) {
    .Call('_SChangeBlock_lrv', PACKAGE = 'SChangeBlock', X, b)
}

#' Autocorrelation matrix
#' 
#' @param X numeric matrix,
#' @param b numeric vector containing exactly two values: the bandwidths for the row- reps. column-wise estimation. 
#' 
#' @export
autocov <- function(X, b, direction = 0L) {
    .Call('_SChangeBlock_autocov', PACKAGE = 'SChangeBlock', X, b, direction)
}

#' Optimal sizes 
#' 
#' @param n integer value.
#' @param lower,upper lower and upper search border, between 0 and 1.
#' @param step size of the step for the search, between 0 and 1.
#' 
#' 
#' @return \code{sSizes} returns a data frame containing
#' \item{n}{the given sample size}
#' \item{s}{the exponent in question}
#' \item{ln}{the resulting block length}
#' \item{bn}{the corresponding number of block}
#' \item{ln.bn}{block length times number of blocks}
#' \item{diff}{difference between the given sample size and the number of observations covered by the blocks}
#' 
#' @examples
#' sSizes(50)
#' sSizes(50, 0.6, 0.8, 0.01)
#' 
#' @rdname sOpt
#' @export
sSizes <- function(n, lower = 0.5, upper = 1, step = 0.1) {
    .Call('_SChangeBlock_sSizes', PACKAGE = 'SChangeBlock', n, lower, upper, step)
}

#' Optimal parameter s
#' 
#' Calculates the best parameter \eqn{\tilde{s}} for a given approximation s, such that \eqn{n \; % \; \[n^{s}\] = 0}.
#' 
#' @param n Sample size(s), numeric (vector).
#' @param s Desired exponent, \eqn{0.5 \leq s \leq 1}.
#' 
#' @return \code{sOpt} returns a numeric vector of the optimal exponent(s).
#' 
#' @examples 
#' sOpt(50, 0.6)
#' sOpt(100, 0.6)
#' 
#' @export
sOpt <- function(n, s = 0.6) {
    .Call('_SChangeBlock_sOpt', PACKAGE = 'SChangeBlock', n, s)
}

